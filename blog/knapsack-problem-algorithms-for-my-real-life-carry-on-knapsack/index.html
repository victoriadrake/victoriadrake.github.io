<!DOCTYPE html>
<html lang="en-us">

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">

<meta name="description" content="Victoria Drake is a senior software developer. She improves software engineering with better systems and processes, and cybersecurity awareness with education.">
<title>
    Knapsack problem algorithms for my real-life carry-on knapsack | victoria.dev
</title>



    <meta
  name="monetization"
  content="$ilp.uphold.com/pBRfRwg2EJAe">

    <meta property="og:title" content="Knapsack problem algorithms for my real-life carry-on knapsack - victoria.dev" />
<meta property="og:type" content="website" />
<meta property="og:description"
    content="Using a greedy algorithm and dynamic programming to pack my full-time nomad travel bag." />
<meta property="og:url" content="https://victoria.dev/blog/knapsack-problem-algorithms-for-my-real-life-carry-on-knapsack/" />
<meta property="og:site_name" content="victoria.dev" />


<meta property="og:image" content="https://victoria.dev/blog/knapsack-problem-algorithms-for-my-real-life-carry-on-knapsack/cover_knapsack-doodle.png"/>


    <meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Knapsack problem algorithms for my real-life carry-on knapsack" />


<meta name="twitter:image" content="https://victoria.dev/blog/knapsack-problem-algorithms-for-my-real-life-carry-on-knapsack/cover_knapsack-doodle.png"/>

<meta name="twitter:description"
    content="Using a greedy algorithm and dynamic programming to pack my full-time nomad travel bag." />

    
<link rel="shortcut icon" href="/img/logo.ico">


    





<link rel="stylesheet" href="/css/main.min.b28e7b7cc6da95528b86dc863a1c5fc36c3ab1630f4acad607bb93bf892ad372.css" integrity="sha256-so57fMbalVKLhtyGOhxfw2w6sWMPSsrWB7uTv4kq03I=" media="screen">





    
    
    
    
</head>

<body>
    <section id="main">

        
        <div class="header">

    <div class="toggle">
        <input type="checkbox" />
        <span class="bar"></span>
        <span class="bar"></span>
        <span class="bar"></span>
        <div id="mobile-menu">
            
            
            <span class="menu-item">
                <a href="/">
                    üë©üèª‚Äçüíª hi</a >
            </span>
            
            <span class="menu-item">
                <a href="/blog/">
                    üì∞ blog</a >
            </span>
            
            <span class="menu-item">
                <a href="/about/">
                    üìñ readme</a >
            </span>
            
            <span class="menu-item">
                <a href="/coffee/">
                    <img src='/coffee/cup.png' alt='coffee icon' height='16px'> contribute</a >
            </span>
            
            
            
            
        </div>
    </div>
    <div id="menu">
        
        
        <span class="menu-item">
            <a href="/">
                üë©üèª‚Äçüíª hi</a >
        </span>
        
        <span class="menu-item">
            <a href="/blog/">
                üì∞ blog</a >
        </span>
        
        <span class="menu-item">
            <a href="/about/">
                üìñ readme</a >
        </span>
        
        <span class="menu-item">
            <a href="/coffee/">
                <img src='/coffee/cup.png' alt='coffee icon' height='16px'> contribute</a >
        </span>
        
        
        
        
    </div>

    <div id="logo">
        <a href="#"><img id="ü•ö" alt="site logo" src="/img/logo.png" /></a>
    </div>

</div>

        

        <div class="container">
            



<div id="cover-image">
    <img src="https://victoria.dev/blog/knapsack-problem-algorithms-for-my-real-life-carry-on-knapsack/cover_knapsack-doodle.png" alt="cover image" />
</div>


            


<div class="markdown">
    <h1>
        Knapsack problem algorithms for my real-life carry-on knapsack
    </h1>
    
    <p class="subtitle">Using a greedy algorithm and dynamic programming to pack my full-time nomad travel bag.</p>
    <p class="metadata" id="date">
        May 9, 2018
        ‚òïÔ∏è‚òïÔ∏è‚òïÔ∏è‚òïÔ∏è‚òïÔ∏è&nbsp;
        24 min read

        
        &nbsp;
        
        <a class="li-tag" href="/tags/algorithms/">
            algorithms
        </a>&nbsp;
        
        <a class="li-tag" href="/tags/computing/">
            computing
        </a>&nbsp;
        
        <a class="li-tag" href="/tags/data/">
            data
        </a>&nbsp;
        
        <a class="li-tag" href="/tags/go/">
            go
        </a>&nbsp;
        
        

        
    </p>

    
    <div class="dropdown">
        <input type="checkbox" id="toc-toggle" />
        <label for="toc-toggle" id="toggle">
            <p class="toc-title">Jump to section...
                <span class="dropdown-icon">‚öì</span>
            </p>
        </label>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#the-set-up">The set up</a></li>
    <li><a href="#data-structures">Data structures</a>
      <ul>
        <li><a href="#reading-in-a-file">Reading in a file</a></li>
        <li><a href="#creating-a-struct">Creating a struct</a></li>
        <li><a href="#parsing-and-storing-our-data">Parsing and storing our data</a></li>
      </ul>
    </li>
    <li><a href="#greedy-algorithm">Greedy algorithm</a>
      <ul>
        <li><a href="#building-our-greedy-algorithm">Building our greedy algorithm</a></li>
        <li><a href="#greedy-algorithm-results">Greedy algorithm results</a></li>
      </ul>
    </li>
    <li><a href="#dynamic-programming">Dynamic programming</a>
      <ul>
        <li><a href="#building-our-dynamic-programming-algorithm">Building our dynamic programming algorithm</a></li>
        <li><a href="#the-verdict">The verdict</a></li>
        <li><a href="#better-algorithm-design">Better algorithm design</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    
</div>

<div class="page-separator">
    <hr />
</div>

<div class="markdown">
    
    <p>I&rsquo;m a nomad and live out of one carry-on bag. This means that the total weight of all my worldly possessions must fall under airline cabin baggage weight limits - usually 10kg. On some smaller airlines, however, this weight limit drops to 7kg. Occasionally, I have to decide not to bring something with me to adjust to the smaller weight limit.</p>
<p>As a practical exercise, deciding what to leave behind (or get rid of altogether) entails laying out all my things and choosing which ones to keep. That decision is based on the item&rsquo;s usefulness to me (its worth) and its weight.</p>
<figure>
    <img src="knapsack-stuff.jpeg"
         alt="All my stuff, laid out flat"/> <figcaption>
            <p>This is all my stuff, and my Minaal Carry-on bag.</p>
        </figcaption>
</figure>

<p>Being a programmer, I&rsquo;m aware that decisions like this could be made more efficiently by a computer. It&rsquo;s done so frequently and so ubiquitously, in fact, that many will recognize this scenario as the classic <em>packing problem</em> or <em>knapsack problem.</em> How do I go about telling a computer to put as many important items in my bag as possible while coming in at or under a weight limit of 7kg? With algorithms! Yay!</p>
<p>I&rsquo;ll discuss two common approaches to solving the knapsack problem: one called a <em>greedy algorithm,</em> and another called <em>dynamic programming</em> (a little harder, but better, faster, stronger&hellip;).</p>
<p>Let&rsquo;s get to it.</p>

<h2 id="the-set-up" class="anchor-link"><a href="#the-set-up">The set up</a></h2>
<p>I prepared my data in the form of a CSV file with three columns: the item&rsquo;s name (a string), a representation of its worth (an integer), and its weight in grams (an integer). There are 40 items in total. I represented worth by ranking each item from 40 to 1, with 40 being the most important and 1 equating with something like &ldquo;why do I even have this again?&rdquo; (If you&rsquo;ve never listed out all your possessions and ranked them by order of how useful they are to you, I highly recommend you try it. It can be a very revealing exercise.)</p>
<p><strong>Total weight of all items and bag:</strong> 9003g</p>
<p><strong>Bag weight:</strong> 1415g</p>
<p><strong>Airline limit:</strong> 7000g</p>
<p><strong>Maximum weight of items I can pack:</strong> 5585g</p>
<p><strong>Total possible worth of items:</strong> 820</p>
<p><strong>The challenge:</strong> Pack as many items as the limit allows while maximizing the total worth.</p>

<h2 id="data-structures" class="anchor-link"><a href="#data-structures">Data structures</a></h2>

<h3 id="reading-in-a-file" class="anchor-link"><a href="#reading-in-a-file">Reading in a file</a></h3>
<p>Before we can begin thinking about how to solve the knapsack problem, we have to solve the problem of reading in and storing our data. Thankfully, the Go standard library&rsquo;s <code>io/ioutil</code> package makes the first part straightforward.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;io/ioutil&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">check</span><span class="p">(</span><span class="nx">e</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">readItems</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">dat</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
 <span class="nf">check</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">dat</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>The <code>ReadFile()</code> function takes a file path and returns the file&rsquo;s contents and an error (<code>nil</code> if the call is successful) so we&rsquo;ve also created a <code>check()</code> function to handle any errors that might be returned. In a real-world application we probably would want to do something more sophisticated than <code>panic</code>, but that&rsquo;s not important right now.</p>

<h3 id="creating-a-struct" class="anchor-link"><a href="#creating-a-struct">Creating a struct</a></h3>
<p>Now that we&rsquo;ve got our data, we should probably do something with it. Since we&rsquo;re working with real-life items and a real-life bag, let&rsquo;s create some types to represent them and make it easier to conceptualize our program. A <code>struct</code> in Go is a typed collection of fields. Here are our two types:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">item</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">name</span>          <span class="kt">string</span>
 <span class="nx">worth</span><span class="p">,</span> <span class="nx">weight</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">bag</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">bagWeight</span><span class="p">,</span> <span class="nx">currItemsWeight</span><span class="p">,</span> <span class="nx">maxItemsWeight</span><span class="p">,</span> <span class="nx">totalWeight</span> <span class="kt">int</span>
 <span class="nx">items</span>                                                   <span class="p">[]</span><span class="nx">item</span>
<span class="p">}</span>
</code></pre></div><p>It is helpful to use field names that are very descriptive. You can see that the structs are set up just as we&rsquo;ve described the things they represent. An <code>item</code> has a <code>name</code> (string), and a <code>worth</code> and <code>weight</code> (integers). A <code>bag</code> has several fields of type <code>int</code> representing its attributes, and also has the ability to hold <code>items</code>, represented in the struct as a slice of <code>item</code> type thingamabobbers.</p>

<h3 id="parsing-and-storing-our-data" class="anchor-link"><a href="#parsing-and-storing-our-data">Parsing and storing our data</a></h3>
<p>Several comprehensive Go packages exist that we could use to parse our CSV data&hellip; but where&rsquo;s the fun in that? Let&rsquo;s go basic with some string splitting and a for loop. Here&rsquo;s our updated <code>readItems()</code> function:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">readItems</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">item</span> <span class="p">{</span>

 <span class="nx">dat</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
 <span class="nf">check</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>

 <span class="nx">lines</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">dat</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>

 <span class="nx">itemList</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

 <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lines</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
   <span class="k">continue</span>
  <span class="p">}</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
  <span class="nx">newItemWorth</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="nx">newItemWeight</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
  <span class="nx">newItem</span> <span class="o">:=</span> <span class="nx">item</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">worth</span><span class="p">:</span> <span class="nx">newItemWorth</span><span class="p">,</span> <span class="nx">weight</span><span class="p">:</span> <span class="nx">newItemWeight</span><span class="p">}</span>
  <span class="nx">itemList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">itemList</span><span class="p">,</span> <span class="nx">newItem</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">itemList</span>
<span class="p">}</span>

</code></pre></div><p>Using <code>strings.Split</code>, we split our <code>dat</code> on newlines. We then create an empty <code>itemList</code> to hold our items.</p>
<p>In our for loop, we skip the first line of our CSV file (the headers) then iterate over each line. We use <code>strconv.Atoi</code> (read &ldquo;A to i&rdquo;) to convert the values for each item&rsquo;s worth and weight into integers. We then create a <code>newItem</code> with these field values and append it to the <code>itemList</code>. Finally, we return <code>itemList</code>.</p>
<p>Here&rsquo;s what our set up looks like so far:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;io/ioutil&#34;</span>
 <span class="s">&#34;strconv&#34;</span>
 <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">item</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">name</span>          <span class="kt">string</span>
 <span class="nx">worth</span><span class="p">,</span> <span class="nx">weight</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">bag</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">bagWeight</span><span class="p">,</span> <span class="nx">currItemsWeight</span><span class="p">,</span> <span class="nx">maxItemsWeight</span><span class="p">,</span> <span class="nx">totalWeight</span><span class="p">,</span> <span class="nx">totalWorth</span> <span class="kt">int</span>
 <span class="nx">items</span>                                                               <span class="p">[]</span><span class="nx">item</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">check</span><span class="p">(</span><span class="nx">e</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">readItems</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">item</span> <span class="p">{</span>

 <span class="nx">dat</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
 <span class="nf">check</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>

 <span class="nx">lines</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">dat</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>

 <span class="nx">itemList</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

 <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lines</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
   <span class="k">continue</span> <span class="c1">// skip the headers on the first line
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
  <span class="nx">newItemWorth</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="nx">newItemWeight</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
  <span class="nx">newItem</span> <span class="o">:=</span> <span class="nx">item</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">worth</span><span class="p">:</span> <span class="nx">newItemWorth</span><span class="p">,</span> <span class="nx">weight</span><span class="p">:</span> <span class="nx">newItemWeight</span><span class="p">}</span>
  <span class="nx">itemList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">itemList</span><span class="p">,</span> <span class="nx">newItem</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">itemList</span>
<span class="p">}</span>
</code></pre></div><p>Now that we&rsquo;ve got our data structures set up, let&rsquo;s get packing (ü•Å) on the first approach.</p>

<h2 id="greedy-algorithm" class="anchor-link"><a href="#greedy-algorithm">Greedy algorithm</a></h2>
<p>A greedy algorithm is the most straightforward approach to solving the knapsack problem, in that it is a one-pass algorithm that constructs a single final solution. At each stage of the problem, the greedy algorithm picks the option that is locally optimal, meaning it looks like the most suitable option right now. It does not revise its previous choices as it progresses through our data set.</p>

<h3 id="building-our-greedy-algorithm" class="anchor-link"><a href="#building-our-greedy-algorithm">Building our greedy algorithm</a></h3>
<p>The steps of the algorithm we&rsquo;ll use to solve our knapsack problem are:</p>
<ol>
<li>Sort items by worth, in descending order.</li>
<li>Start with the highest worth item. Put items into the bag until the next item on the list cannot fit.</li>
<li>Try to fill any remaining capacity with the next item on the list that can fit.</li>
</ol>
<p>If you read my <a href="/blog/how-to-code-a-satellite-algorithm-and-cook-paella-from-scratch/">article about solving problems and making paella</a>, you&rsquo;ll know that I always start by figuring out what the next most important question is. In this case, there are three main operations we need to figure out how to do:</p>
<ul>
<li>Sort items by worth.</li>
<li>Put an item in the bag.</li>
<li>Check to see if the bag is full.</li>
</ul>
<p>The first one is just a docs lookup away. Here&rsquo;s how we sort a slice in Go:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">sort</span><span class="p">.</span><span class="nf">Slice</span><span class="p">(</span><span class="nx">is</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">is</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">worth</span> <span class="p">&gt;</span> <span class="nx">is</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">worth</span>
<span class="p">})</span>
</code></pre></div><p>The <code>sort.Slice()</code> function orders our items according to the less function we provide. In this case, it will order the highest worth items before the lowest worth items.</p>
<p>Given that we don&rsquo;t want to put an item in the bag if it doesn&rsquo;t fit, we&rsquo;ll complete the last two tasks in reverse. First, we&rsquo;ll check to see if the item fits. If so, it goes in the bag.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bag</span><span class="p">)</span> <span class="nf">addItem</span><span class="p">(</span><span class="nx">i</span> <span class="nx">item</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
 <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">currItemsWeight</span><span class="o">+</span><span class="nx">i</span><span class="p">.</span><span class="nx">weight</span> <span class="o">&lt;=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxItemsWeight</span> <span class="p">{</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">currItemsWeight</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">.</span><span class="nx">weight</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">items</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">items</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;could not fit item&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Notice the <code>*</code> in our first line there. That indicates that <code>bag</code> is a pointer receiver (as opposed to a value receiver). It&rsquo;s a concept that can be slightly confusing if you&rsquo;re new to Go. Here are <a href="https://github.com/golang/go/wiki/CodeReviewComments#receiver-type">some things to consider</a> that might help you decide when to use a value receiver and when to use a pointer receiver. For the purposes of our <code>addItem()</code> function, this case applies:</p>
<blockquote>
<p>If the method needs to mutate the receiver, the receiver must be a pointer.</p>
</blockquote>
<p>Our use of a pointer receiver tells our function we want to operate on <em>this specific bag in particular</em>, not a new bag. It&rsquo;s important because without it, every item would always fit in a newly created bag! A little detail like this can make the difference between code that works and code that keeps you up until 4am chugging Red Bull and muttering to yourself. (Go to bed on time even if your code doesn&rsquo;t work - you&rsquo;ll thank me later.)</p>
<p>Now that we&rsquo;ve got our components, let&rsquo;s put together our greedy algorithm:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">greedy</span><span class="p">(</span><span class="nx">is</span> <span class="p">[]</span><span class="nx">item</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">bag</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">sort</span><span class="p">.</span><span class="nf">Slice</span><span class="p">(</span><span class="nx">is</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">is</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">worth</span> <span class="p">&gt;</span> <span class="nx">is</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">worth</span>
 <span class="p">})</span>

 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">is</span> <span class="p">{</span>
  <span class="nx">b</span><span class="p">.</span><span class="nf">addItem</span><span class="p">(</span><span class="nx">is</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
 <span class="p">}</span>

 <span class="nx">b</span><span class="p">.</span><span class="nx">totalWeight</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">bagWeight</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">currItemsWeight</span>

 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span><span class="p">.</span><span class="nx">items</span> <span class="p">{</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">totalWorth</span> <span class="o">+=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">worth</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Then in our <code>main()</code> function, we&rsquo;ll create our bag, read in our data, and call our greedy algorithm. Here&rsquo;s what it looks like, all set up and ready to go:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

 <span class="nx">minaal</span> <span class="o">:=</span> <span class="nx">bag</span><span class="p">{</span><span class="nx">bagWeight</span><span class="p">:</span> <span class="mi">1415</span><span class="p">,</span> <span class="nx">currItemsWeight</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">maxItemsWeight</span><span class="p">:</span> <span class="mi">5585</span><span class="p">}</span>
 <span class="nx">itemList</span> <span class="o">:=</span> <span class="nf">readItems</span><span class="p">(</span><span class="s">&#34;objects.csv&#34;</span><span class="p">)</span>

 <span class="nf">greedy</span><span class="p">(</span><span class="nx">itemList</span><span class="p">,</span> <span class="nx">minaal</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="greedy-algorithm-results" class="anchor-link"><a href="#greedy-algorithm-results">Greedy algorithm results</a></h3>
<p>So how does this algorithm do when it comes to efficiently packing our bag to maximize its total worth? Here&rsquo;s the result:</p>
<p><strong>Total weight of bag and items:</strong> 6987g</p>
<p><strong>Total worth of packed items:</strong> 716</p>
<p>Here are the items our greedy algorithm chose, sorted by worth:</p>
<table>
<thead>
<tr>
<th>Item</th>
<th>Worth</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lenovo X1 Carbon (5th Gen)</td>
<td>40</td>
<td>112</td>
</tr>
<tr>
<td>10 pairs thongs</td>
<td>39</td>
<td>80</td>
</tr>
<tr>
<td>5 Underarmour Strappy</td>
<td>38</td>
<td>305</td>
</tr>
<tr>
<td>1 pair Uniqlo leggings</td>
<td>37</td>
<td>185</td>
</tr>
<tr>
<td>2 Lululemon Cool Racerback</td>
<td>36</td>
<td>174</td>
</tr>
<tr>
<td>Chargers and cables in Mini Bomber Travel Kit</td>
<td>35</td>
<td>665</td>
</tr>
<tr>
<td>The Roost Stand</td>
<td>34</td>
<td>170</td>
</tr>
<tr>
<td>ThinkPad Compact Bluetooth Keyboard with trackpoint</td>
<td>33</td>
<td>460</td>
</tr>
<tr>
<td>Seagate Backup PlusSlim</td>
<td>32</td>
<td>159</td>
</tr>
<tr>
<td>1 pair black denim shorts</td>
<td>31</td>
<td>197</td>
</tr>
<tr>
<td>2 pairs Nike Pro shorts</td>
<td>30</td>
<td>112</td>
</tr>
<tr>
<td>2 pairs Lululemon shorts</td>
<td>29</td>
<td>184</td>
</tr>
<tr>
<td>Isabella T-Strap Croc sandals</td>
<td>28</td>
<td>200</td>
</tr>
<tr>
<td>2 Underarmour HeatGear CoolSwitch tank tops</td>
<td>27</td>
<td>138</td>
</tr>
<tr>
<td>5 pairs black socks</td>
<td>26</td>
<td>95</td>
</tr>
<tr>
<td>2 pairs Injinji Women&rsquo;s Run Lightweight No-Show Toe Socks</td>
<td>25</td>
<td>54</td>
</tr>
<tr>
<td>1 fancy tank top</td>
<td>24</td>
<td>71</td>
</tr>
<tr>
<td>1 light and stretchylong-sleeve shirt (Gap Fit)</td>
<td>23</td>
<td>147</td>
</tr>
<tr>
<td>Uniqlo Ultralight Down insulating jacket</td>
<td>22</td>
<td>235</td>
</tr>
<tr>
<td>Patagonia Torrentshell</td>
<td>21</td>
<td>301</td>
</tr>
<tr>
<td>Lightweight Merino Wool Buff</td>
<td>20</td>
<td>50</td>
</tr>
<tr>
<td>1 LBD (H&amp;M)</td>
<td>19</td>
<td>174</td>
</tr>
<tr>
<td>Field Notes Pitch Black Memo Book Dot-Graph</td>
<td>18</td>
<td>68</td>
</tr>
<tr>
<td>Innergie PocketCell USB-C 6000mAh power bank</td>
<td>17</td>
<td>14</td>
</tr>
<tr>
<td>JBL Reflect Mini Bluetooth Sport Headphones</td>
<td>13</td>
<td>14</td>
</tr>
<tr>
<td>Oakley Latch Sunglasses</td>
<td>11</td>
<td>30</td>
</tr>
<tr>
<td>Petzl E+LITE Emergency Headlamp</td>
<td>8</td>
<td>27</td>
</tr>
</tbody>
</table>
<p>It&rsquo;s clear that the greedy algorithm is a straightforward way to quickly find a feasible solution. For small data sets, it will probably be close to the optimal solution. The algorithm packed a total item worth of 716 (104 points less than the maximum possible value), while filling the bag with just 13g left over.</p>
<p>As we learned earlier, the greedy algorithm doesn&rsquo;t improve upon the solution it returns. It simply adds the next highest worth item it can to the bag.</p>
<p>Let&rsquo;s look at another method for solving the knapsack problem that will give us the optimal solution - the highest possible total worth under the weight limit.</p>

<h2 id="dynamic-programming" class="anchor-link"><a href="#dynamic-programming">Dynamic programming</a></h2>
<p>The name &ldquo;dynamic programming&rdquo; can be a bit misleading. It&rsquo;s not a style of programming, as the name might cause you to infer, but simply another approach.</p>
<p>Dynamic programming differs from the straightforward greedy algorithm in a few key ways. Firstly, a dynamic programming bag packing solution enumerates the entire solution space with all possibilities of item combinations that could be used to pack our bag. Where a greedy algorithm chooses the most optimal <em>local</em> solution, dynamic programming algorithms are able to find the most optimal <em>global</em> solution.</p>
<p>Secondly, dynamic programming uses memoization to store the results of previously computed operations and returns the cached result when the operation occurs again. This allows it to &ldquo;remember&rdquo; previous combinations. This takes less time than it would to re-compute the answer again.</p>

<h3 id="building-our-dynamic-programming-algorithm" class="anchor-link"><a href="#building-our-dynamic-programming-algorithm">Building our dynamic programming algorithm</a></h3>
<p>To use dynamic programming to find the optimal recipe for packing our bag, we&rsquo;ll need to:</p>
<ol>
<li>Create a matrix representing all subsets of the items (the solution space) with rows representing items and columns representing the bag&rsquo;s remaining weight capacity</li>
<li>Loop through the matrix and calculate the worth that can be obtained by each combination of items at each stage of the bag&rsquo;s capacity</li>
<li>Examine the completed matrix to determine which items to add to the bag in order to produce the maximum possible worth for the bag in total</li>
</ol>
<p>It will be most helpful to visualize our solution space. Here&rsquo;s a representation of what we&rsquo;re building with our code:</p>
<figure>
    <img src="knapsack-matrix.jpg"
         alt="A sketch of the matrix with rows for items and columns for grams of weight."/> <figcaption>
            <p>The empty knapsackian multiverse.</p>
        </figcaption>
</figure>

<p>In Go, we can create this matrix as a slice of slices.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">matrix</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">numItems</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// rows representing items
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">matrix</span> <span class="p">{</span>
 <span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">capacity</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// columns representing grams of weight
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>We&rsquo;ve padded the rows and columns by <code>1</code> so that the indicies match the item and weight numbers.</p>
<p>Now that we&rsquo;ve created our matrix, we&rsquo;ll fill it by looping over the rows and the columns:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// loop through table rows
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">numItems</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
 <span class="c1">// loop through table columns
</span><span class="c1"></span> <span class="k">for</span> <span class="nx">w</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">w</span> <span class="o">&lt;=</span> <span class="nx">capacity</span><span class="p">;</span> <span class="nx">w</span><span class="o">++</span> <span class="p">{</span>
  <span class="c1">// do stuff in each element
</span><span class="c1"></span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Then for each element, we&rsquo;ll calculate the worth value to ascribe to it. We do this with code that represents the following:</p>
<blockquote>
<p>If the item at the index matching the current row fits within the weight capacity represented by the current column, take the maximum of either:
In other words, as our algorithm considers one of the items, we&rsquo;re asking it to decide whether this item added to the bag would produce a higher total worth than the last item it added to the bag, at the bag&rsquo;s current total weight. If this current item is a better choice, put it in - if not, leave it out.</p>
</blockquote>
<p>Here&rsquo;s the code that accomplishes this:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// if weight of item matching this index can fit at the current capacity column...
</span><span class="c1"></span><span class="k">if</span> <span class="nx">is</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">weight</span> <span class="o">&lt;=</span> <span class="nx">w</span> <span class="p">{</span>
 <span class="c1">// worth of this subset without this item
</span><span class="c1"></span> <span class="nx">valueOne</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">w</span><span class="p">])</span>
 <span class="c1">// worth of this subset without the previous item, and this item instead
</span><span class="c1"></span> <span class="nx">valueTwo</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">is</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">worth</span> <span class="o">+</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">w</span><span class="o">-</span><span class="nx">is</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">weight</span><span class="p">])</span>
 <span class="c1">// take maximum of either valueOne or valueTwo
</span><span class="c1"></span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">w</span><span class="p">]</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="nx">valueOne</span><span class="p">,</span> <span class="nx">valueTwo</span><span class="p">))</span>
 <span class="o">/</span> <span class="k">if</span> <span class="nx">the</span> <span class="nx">new</span> <span class="nx">worth</span> <span class="nx">is</span> <span class="nx">not</span> <span class="nx">more</span><span class="p">,</span> <span class="nx">carry</span> <span class="nx">over</span> <span class="nx">the</span> <span class="nx">previous</span> <span class="nx">worth</span>
  <span class="k">else</span> <span class="p">{</span>
 <span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">w</span><span class="p">]</span> <span class="p">=</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">w</span><span class="p">]</span>

 <span class="s">``</span>

<span class="nx">This</span> <span class="nx">process</span> <span class="nx">of</span> <span class="nx">comparing</span> <span class="nx">item</span> <span class="nx">combinations</span> <span class="nx">will</span> <span class="k">continue</span> <span class="nx">until</span> <span class="nx">every</span> <span class="nx">item</span> <span class="nx">has</span> <span class="nx">been</span> <span class="nx">considered</span> <span class="nx">at</span> <span class="nx">every</span> <span class="nx">possible</span> <span class="nx">stage</span> <span class="nx">of</span> <span class="nx">the</span> <span class="nx">bag</span><span class="err">&#39;</span><span class="nx">s</span> <span class="nx">increasing</span> <span class="nx">total</span> <span class="nx">weight</span><span class="p">.</span> <span class="nx">When</span> <span class="nx">all</span> <span class="nx">the</span> <span class="nx">above</span> <span class="nx">have</span> <span class="nx">been</span> <span class="nx">considered</span><span class="p">,</span> <span class="nx">we</span><span class="err">&#39;</span><span class="nx">ll</span> <span class="nx">have</span> <span class="nx">enumerated</span> <span class="nx">the</span> <span class="nx">solution</span> <span class="nx">space</span> <span class="o">-</span> <span class="nx">filled</span> <span class="nx">the</span> <span class="nx">matrix</span> <span class="o">-</span> <span class="nx">with</span> <span class="nx">all</span> <span class="nx">possible</span> <span class="nx">total</span> <span class="nx">worth</span> <span class="nx">values</span><span class="p">.</span>

<span class="nx">We</span><span class="err">&#39;</span><span class="nx">ll</span> <span class="nx">have</span> <span class="nx">a</span> <span class="nx">big</span> <span class="nx">chart</span> <span class="nx">of</span> <span class="nx">numbers</span><span class="p">,</span> <span class="nx">and</span> <span class="nx">in</span> <span class="nx">the</span> <span class="nx">last</span> <span class="nx">column</span> <span class="nx">at</span> <span class="nx">the</span> <span class="nx">last</span> <span class="nx">row</span> <span class="nx">we</span><span class="err">&#39;</span><span class="nx">ll</span> <span class="nx">have</span> <span class="nx">our</span> <span class="nx">highest</span> <span class="nx">possible</span> <span class="nx">value</span><span class="p">.</span>

<span class="nx"></span>

<span class="nx">That</span><span class="err">&#39;</span><span class="nx">s</span> <span class="nx">great</span><span class="p">,</span> <span class="nx">but</span> <span class="nx">how</span> <span class="nx">do</span> <span class="nx">we</span> <span class="nx">find</span> <span class="nx">out</span> <span class="nx">which</span> <span class="nx">combination</span> <span class="nx">of</span> <span class="nx">items</span> <span class="nx">were</span> <span class="nx">put</span> <span class="nx">in</span> <span class="nx">the</span> <span class="nx">bag</span> <span class="nx">to</span> <span class="nx">achieve</span> <span class="nx">that</span> <span class="nx">worth</span><span class="err">?</span>

<span class="err">###</span> <span class="nx">Getting</span> <span class="nx">our</span> <span class="nx">optimized</span> <span class="nx">item</span> <span class="nx">list</span>

<span class="nx">To</span> <span class="nx">see</span> <span class="nx">which</span> <span class="nx">items</span> <span class="nx">combine</span> <span class="nx">to</span> <span class="nx">create</span> <span class="nx">our</span> <span class="nx">optimal</span> <span class="nx">packing</span> <span class="nx">list</span><span class="p">,</span> <span class="nx">we</span><span class="err">&#39;</span><span class="nx">ll</span> <span class="nx">need</span> <span class="nx">to</span> <span class="nx">examine</span> <span class="nx">our</span> <span class="nx">matrix</span> <span class="nx">in</span> <span class="nx">reverse</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">way</span> <span class="nx">we</span> <span class="nx">created</span> <span class="nx">it</span><span class="p">.</span> <span class="nx">Since</span> <span class="nx">we</span> <span class="nx">know</span> <span class="nx">the</span> <span class="nx">highest</span> <span class="nx">possible</span> <span class="nx">value</span> <span class="nx">is</span> <span class="nx">in</span> <span class="nx">the</span> <span class="nx">last</span> <span class="nx">row</span> <span class="nx">in</span> <span class="nx">the</span> <span class="nx">last</span> <span class="nx">column</span><span class="p">,</span> <span class="nx">we</span><span class="err">&#39;</span><span class="nx">ll</span> <span class="nx">start</span> <span class="nx">there</span><span class="p">.</span> <span class="nx">To</span> <span class="nx">find</span> <span class="nx">the</span> <span class="nx">items</span><span class="p">,</span> <span class="nx">we</span><span class="p">:</span>

<span class="mf">1.</span> <span class="nx">Get</span> <span class="nx">the</span> <span class="nx">value</span> <span class="nx">of</span> <span class="nx">the</span> <span class="nx">current</span> <span class="nx">cell</span>
<span class="mf">1.</span> <span class="nx">Compare</span> <span class="nx">the</span> <span class="nx">value</span> <span class="nx">of</span> <span class="nx">the</span> <span class="nx">current</span> <span class="nx">cell</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">value</span> <span class="nx">in</span> <span class="nx">the</span> <span class="nx">cell</span> <span class="nx">directly</span> <span class="nx">above</span> <span class="nx">it</span>
<span class="mf">1.</span> <span class="nx">If</span> <span class="nx">the</span> <span class="nx">values</span> <span class="nx">differ</span><span class="p">,</span> <span class="nx">there</span> <span class="nx">was</span> <span class="nx">a</span> <span class="nx">change</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">bag</span> <span class="nx">items</span><span class="p">;</span> <span class="nx">find</span> <span class="nx">the</span> <span class="nx">next</span> <span class="nx">cell</span> <span class="nx">to</span> <span class="nx">examine</span> <span class="nx">by</span> <span class="nx">moving</span> <span class="nx">backwards</span> <span class="nx">through</span> <span class="nx">the</span> <span class="nx">columns</span> <span class="nx">according</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">current</span> <span class="nx">item</span><span class="err">&#39;</span><span class="nx">s</span> <span class="nf">weight</span> <span class="p">(</span><span class="nx">find</span> <span class="nx">the</span> <span class="nx">value</span> <span class="nx">of</span> <span class="nx">the</span> <span class="nx">bag</span> <span class="nx">before</span> <span class="nx">this</span> <span class="nx">current</span> <span class="nx">item</span> <span class="nx">was</span> <span class="nx">added</span><span class="p">)</span>
<span class="mf">1.</span> <span class="nx">If</span> <span class="nx">the</span> <span class="nx">values</span> <span class="nx">match</span><span class="p">,</span> <span class="nx">there</span> <span class="nx">was</span> <span class="nx">no</span> <span class="nx">change</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">bag</span> <span class="nx">items</span><span class="p">;</span> <span class="nx">move</span> <span class="nx">up</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">cell</span> <span class="nx">in</span> <span class="nx">the</span> <span class="nx">row</span> <span class="nx">above</span> <span class="nx">and</span> <span class="nx">repeat</span>

<span class="nx">The</span> <span class="nx">nature</span> <span class="nx">of</span> <span class="nx">the</span> <span class="nx">action</span> <span class="nx">we</span><span class="err">&#39;</span><span class="nx">re</span> <span class="nx">trying</span> <span class="nx">to</span> <span class="nx">achieve</span> <span class="nx">lends</span> <span class="nx">itself</span> <span class="nx">well</span> <span class="nx">to</span> <span class="nx">a</span> <span class="nx">recursive</span> <span class="nx">function</span><span class="p">.</span> <span class="nx">If</span> <span class="nx">you</span> <span class="nx">recall</span> <span class="nx">from</span> <span class="p">[</span><span class="nx">my</span> <span class="nx">previous</span> <span class="nx">article</span> <span class="nx">about</span> <span class="nx">making</span> <span class="nx">apple</span> <span class="nx">pie</span><span class="p">](</span><span class="o">/</span><span class="nx">blog</span><span class="o">/</span><span class="nx">understanding</span><span class="o">-</span><span class="nx">array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">reduce</span><span class="o">-</span><span class="nx">and</span><span class="o">-</span><span class="nx">recursion</span><span class="o">-</span><span class="nx">using</span><span class="o">-</span><span class="nx">apple</span><span class="o">-</span><span class="nx">pie</span><span class="o">/</span><span class="p">),</span> <span class="nx">recursive</span> <span class="nx">functions</span> <span class="nx">are</span> <span class="nx">simply</span> <span class="nx">functions</span> <span class="nx">that</span> <span class="nx">call</span> <span class="nx">themselves</span> <span class="nx">under</span> <span class="nx">certain</span> <span class="nx">conditions</span><span class="p">.</span> <span class="nx">Here</span><span class="err">&#39;</span><span class="nx">s</span> <span class="nx">what</span> <span class="nx">it</span> <span class="nx">looks</span> <span class="nx">like</span><span class="p">:</span>

<span class="s">```go
</span><span class="s">func checkItem(b *bag, i int, w int, is []item, matrix [][]int) {
</span><span class="s"> if i &lt;= 0 || w &lt;= 0 {
</span><span class="s">  return
</span><span class="s">
</span><span class="s">
</span><span class="s">  ick := matrix[i][w]
</span><span class="s"> if pick != matrix[i-1][w] {
</span><span class="s">  b.addItem(is[i-1])
</span><span class="s">  checkItem(b, i-1, w-is[i-1].weight, is, matrix)
</span><span class="s">   else {
</span><span class="s">  checkItem(b, i-1, w, is, matrix)
</span><span class="s">
</span><span class="s">
</span><span class="s">  `</span>

<span class="nx">Our</span> <span class="s">`checkItem()`</span> <span class="nx">function</span> <span class="nx">calls</span> <span class="nx">itself</span> <span class="k">if</span> <span class="nx">the</span> <span class="nx">condition</span> <span class="nx">we</span> <span class="nx">described</span> <span class="nx">in</span> <span class="nx">step</span> <span class="mi">4</span> <span class="nx">is</span> <span class="kc">true</span><span class="p">.</span> <span class="nx">If</span> <span class="nx">step</span> <span class="mi">3</span> <span class="nx">is</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">it</span> <span class="nx">also</span> <span class="nx">calls</span> <span class="nx">itself</span><span class="p">,</span> <span class="nx">but</span> <span class="nx">with</span> <span class="nx">different</span> <span class="nx">arguments</span><span class="p">.</span>

<span class="nx">Recursive</span> <span class="nx">functions</span> <span class="nx">require</span> <span class="nx">a</span> <span class="nx">base</span> <span class="k">case</span><span class="p">.</span> <span class="nx">In</span> <span class="nx">this</span> <span class="nx">example</span><span class="p">,</span> <span class="nx">we</span> <span class="nx">want</span> <span class="nx">the</span> <span class="nx">function</span> <span class="nx">to</span> <span class="nx">stop</span> <span class="nx">once</span> <span class="nx">we</span> <span class="nx">run</span> <span class="nx">out</span> <span class="nx">of</span> <span class="nx">values</span> <span class="nx">of</span> <span class="nx">worth</span> <span class="nx">to</span> <span class="nx">compare</span><span class="p">.</span> <span class="nx">Thus</span> <span class="nx">our</span> <span class="nx">base</span> <span class="k">case</span> <span class="nx">is</span> <span class="nx">when</span> <span class="nx">either</span> <span class="s">`i`</span> <span class="nx">or</span> <span class="s">`w`</span> <span class="nx">are</span> <span class="s">`0`</span><span class="p">.</span>

<span class="nx">Here</span><span class="err">&#39;</span><span class="nx">s</span> <span class="nx">how</span> <span class="nx">the</span> <span class="nx">dynamic</span> <span class="nx">programming</span> <span class="nx">approach</span> <span class="nx">looks</span> <span class="nx">when</span> <span class="nx">it</span><span class="err">&#39;</span><span class="nx">s</span> <span class="nx">all</span> <span class="nx">put</span> <span class="nx">together</span><span class="p">:</span>

<span class="s">```go
</span><span class="s">func checkItem(b *bag, i int, w int, is []item, matrix [][]int) {
</span><span class="s"> if i &lt;= 0 || w &lt;= 0 {
</span><span class="s">  return
</span><span class="s">
</span><span class="s">
</span><span class="s">  ick := matrix[i][w]
</span><span class="s"> if pick != matrix[i-1][w] {
</span><span class="s">  b.addItem(is[i-1])
</span><span class="s">  checkItem(b, i-1, w-is[i-1].weight, is, matrix)
</span><span class="s">   else {
</span><span class="s">  checkItem(b, i-1, w, is, matrix)
</span><span class="s">
</span><span class="s">
</span><span class="s">
</span><span class="s"> unc dynamic(is []item, b *bag) *bag {
</span><span class="s"> numItems := len(is)          // number of items in knapsack
</span><span class="s"> capacity := b.maxItemsWeight // capacity of knapsack
</span><span class="s">
</span><span class="s"> // create the empty matrix
</span><span class="s"> matrix := make([][]int, numItems+1) // rows representing items
</span><span class="s"> for i := range matrix {
</span><span class="s">  matrix[i] = make([]int, capacity+1) // columns representing grams of weight
</span><span class="s">
</span><span class="s">
</span><span class="s">  / loop through table rows
</span><span class="s"> for i := 1; i &lt;= numItems; i++ {
</span><span class="s">  // loop through table columns
</span><span class="s">  for w := 1; w &lt;= capacity; w++ {
</span><span class="s">
</span><span class="s">   // if weight of item matching this index can fit at the current capacity column...
</span><span class="s">   if is[i-1].weight &lt;= w {
</span><span class="s">    // worth of this subset without this item
</span><span class="s">    valueOne := float64(matrix[i-1][w])
</span><span class="s">    // worth of this subset without the previous item, and this item instead
</span><span class="s">    valueTwo := float64(is[i-1].worth + matrix[i-1][w-is[i-1].weight])
</span><span class="s">    // take maximum of either valueOne or valueTwo
</span><span class="s">    matrix[i][w] = int(math.Max(valueOne, valueTwo))
</span><span class="s">    / if the new worth is not more, carry over the previous worth
</span><span class="s">     else {
</span><span class="s">    matrix[i][w] = matrix[i-1][w]
</span><span class="s">
</span><span class="s">
</span><span class="s">
</span><span class="s">
</span><span class="s">  heckItem(b, numItems, capacity, is, matrix)
</span><span class="s">
</span><span class="s"> // add other statistics to the bag
</span><span class="s"> b.totalWorth = matrix[numItems][capacity]
</span><span class="s"> b.totalWeight = b.bagWeight + b.currItemsWeight
</span><span class="s">
</span><span class="s"> return b
</span><span class="s">
</span><span class="s"> ``
</span><span class="s">
</span><span class="s">### Dynamic programming results
</span><span class="s">
</span><span class="s">We expect that the dynamic programming approach will give us a more optimized solution than the greedy algorithm. So did it? Here are the results:
</span><span class="s">
</span><span class="s">**Total weight of bag and items:** 6982g
</span><span class="s">
</span><span class="s">**Total worth of packed items:** 757
</span><span class="s">
</span><span class="s">Here are the items our dynamic programming algorithm chose, sorted by worth:
</span><span class="s">
</span><span class="s">| Item                                                      | Worth | Weight |
</span><span class="s">| --------------------------------------------------------- | ----- | ------ |
</span><span class="s">| 10 pairs thongs                                           | 39    | 80     |
</span><span class="s">| 5 Underarmour Strappy                                     | 38    | 305    |
</span><span class="s">| 1 pair Uniqlo leggings                                    | 37    | 185    |
</span><span class="s">| 2 Lululemon Cool Racerback                                | 36    | 174    |
</span><span class="s">| Chargers and cables in Mini Bomber Travel Kit             | 35    | 665    |
</span><span class="s">| The Roost Stand                                           | 34    | 170    |
</span><span class="s">| ThinkPad Compact Bluetooth Keyboard with trackpoint       | 33    | 460    |
</span><span class="s">| Seagate Backup Plus Slim                                  | 32    | 159    |
</span><span class="s">| 1 pair black denim shorts                                 | 31    | 197    |
</span><span class="s">| 2 pairs Nike Pro shorts                                   | 30    | 112    |
</span><span class="s">| 2 pairs Lululemon shorts                                  | 29    | 184    |
</span><span class="s">| Isabella T-Strap Croc sandals                             | 28    | 200    |
</span><span class="s">| 2 Underarmour HeatGear CoolSwitch tank tops               | 27    | 138    |
</span><span class="s">| 5 pairs black socks                                       | 26    | 95     |
</span><span class="s">| 2 pairs Injinji Women&#39;s Run Lightweight No-Show Toe Socks | 25    | 54     |
</span><span class="s">| 1 fancy tank top                                          | 24    | 71     |
</span><span class="s">| 1 light and stretchy long-sleeve shirt (Gap Fit)          | 23    | 147    |
</span><span class="s">| Uniqlo Ultralight Down insulating jacket                  | 22    | 235    |
</span><span class="s">| Patagonia Torrentshell                                    | 21    | 301    |
</span><span class="s">| Lightweight Merino Wool Buff                              | 20    | 50     |
</span><span class="s">| 1 LBD (H&amp;M)                                               | 19    | 174    |
</span><span class="s">| Field Notes Pitch Black Memo Book Dot-Graph               | 18    | 68     |
</span><span class="s">| Innergie PocketCell USB-C 6000mAh power bank              | 17    | 148    |
</span><span class="s">| Important papers                                          | 16    | 228    |
</span><span class="s">| Deuter First Aid Kit Active                               | 15    | 144    |
</span><span class="s">| Stanley Classic Vacuum Camp Mug 16oz                      | 14    | 454    |
</span><span class="s">| JBL Reflect Mini Bluetooth Sport Headphones               | 13    | 14     |
</span><span class="s">| Anker SoundCore nano Bluetooth Speaker                    | 12    | 80     |
</span><span class="s">| Oakley Latch Sunglasses                                   | 11    | 30     |
</span><span class="s">| Ray Ban Wayfarer Classic                                  | 10    | 45     |
</span><span class="s">| Petzl E+LITE Emergency Headlamp                           | 8     | 27     |
</span><span class="s">| Peak Design Cuff Camera Wrist Strap                       | 6     | 26     |
</span><span class="s">| Travelon Micro Scale                                      | 5     | 125    |
</span><span class="s">| Humangear GoBites Duo                                     | 3     | 22     |
</span><span class="s">
</span><span class="s">There&#39;s an obvious improvement to our dynamic programming solution over what the greedy algorithm gave us. Our total worth of 757 is 41 points greater than the greedy algorithm&#39;s solution of 716, and for a few grams less weight too!
</span><span class="s">
</span><span class="s">### Input sort order
</span><span class="s">
</span><span class="s">While testing my dynamic programming solution, I implemented the [Fisher-Yates shuffle algorithm](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle) on the input before passing it into my function, just to ensure that the answer wasn&#39;t somehow dependent on the sort order of the input. Here&#39;s what the shuffle looks like in Go:
</span><span class="s">
</span><span class="s">```</span><span class="k">go</span>
<span class="nx">rand</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())</span>

<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">itemList</span> <span class="p">{</span>
 <span class="nx">j</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
 <span class="nx">itemList</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">itemList</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">itemList</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">itemList</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

 <span class="s">``</span>

<span class="nx">Of</span> <span class="nx">course</span> <span class="nx">I</span> <span class="nx">then</span> <span class="nx">realized</span> <span class="nx">that</span> <span class="nx">Go</span> <span class="mf">1.10</span> <span class="nx">now</span> <span class="nx">has</span> <span class="nx">a</span> <span class="nx">built</span><span class="o">-</span><span class="nx">in</span> <span class="nx">shuffle</span><span class="o">...</span> <span class="nx">it</span> <span class="nx">works</span> <span class="nx">precisely</span> <span class="nx">the</span> <span class="nx">same</span> <span class="nx">way</span> <span class="nx">and</span> <span class="nx">looks</span> <span class="nx">like</span> <span class="nx">this</span><span class="p">:</span>

<span class="s">```go
</span><span class="s">rand.Shuffle(len(itemList), func(i, j int) {
</span><span class="s"> itemList[i], itemList[j] = itemList[j], itemList[i]
</span><span class="s"> )
</span><span class="s"> ``
</span><span class="s">
</span><span class="s">So did the order in which the items were processed affect the outcome? Well...
</span><span class="s">
</span><span class="s">#### Suddenly... a rogue weight appears
</span><span class="s">
</span><span class="s">As it turns out, in a way, the answer dd depend on the order of the input. When I ran my dynamic programming algorithm several times, I sometimes saw a different total weight for the bag, though the total worth remained at 757. I initially thought this was a bug before examining the two sets of items that accompanied the two different total weight values. Everything was the same except for a few changes that collectively added up to a different item subset accounting for 14 of the 757 worth points.
</span><span class="s">
</span><span class="s">In this case, there were two equally optimal solutions based only on the success metric of the highest total possible worth. Shuffling the input seemed to affect the placement of the items in the matrix and thus, the path that the `</span><span class="nf">checkItem</span><span class="p">()</span><span class="s">` function took as it went through the matrix to find the chosen items. Since the success metric of having the highest possible worth was the same in both item sets, we don&#39;t have a single unique solution - there&#39;s two!
</span><span class="s">
</span><span class="s">As an academic exercise, both these sets of items are correct answers. We may choose to optimize further by another metric, say, the total weight of all the items. The highest possible worth at the least possible weight could be seen as an ideal solution.
</span><span class="s">
</span><span class="s">Here&#39;s the second, lighter, dynamic programming result:
</span><span class="s">
</span><span class="s">**Total weight of bag and items:** 6955g
</span><span class="s">
</span><span class="s">**Total worth of packed items:** 757
</span><span class="s">
</span><span class="s">| Item                                                      | Worth | Weight |
</span><span class="s">| --------------------------------------------------------- | ----- | ------ |
</span><span class="s">| 10 pairs thongs                                           | 39    | 80     |
</span><span class="s">| 5 Underarmour Strappy                                     | 38    | 305    |
</span><span class="s">| 1 pair Uniqlo leggings                                    | 37    | 185    |
</span><span class="s">| 2 Lululemon Cool Racerback                                | 36    | 174    |
</span><span class="s">| Chargers and cables in Mini Bomber Travel Kit             | 35    | 665    |
</span><span class="s">| The Roost Stand                                           | 34    | 170    |
</span><span class="s">| ThinkPad Compact Bluetooth Keyboard with trackpoint       | 33    | 460    |
</span><span class="s">| Seagate Backup Plus Slim                                  | 32    | 159    |
</span><span class="s">| 1 pair black denim shorts                                 | 31    | 197    |
</span><span class="s">| 2 pairs Nike Pro shorts                                   | 30    | 112    |
</span><span class="s">| 2 pairs Lululemon shorts                                  | 29    | 184    |
</span><span class="s">| Isabella T-Strap Croc sandals                             | 28    | 200    |
</span><span class="s">| 2 Underarmour HeatGear CoolSwitch tank tops               | 27    | 138    |
</span><span class="s">| 5 pairs black socks                                       | 26    | 95     |
</span><span class="s">| 2 pairs Injinji Women&#39;s Run Lightweight No-Show Toe Socks | 25    | 54     |
</span><span class="s">| 1 fancy tank top                                          | 24    | 71     |
</span><span class="s">| 1 light and stretchy long-sleeve shirt (Gap Fit)          | 23    | 147    |
</span><span class="s">| Uniqlo Ultralight Down insulating jacket                  | 22    | 235    |
</span><span class="s">| Patagonia Torrentshell                                    | 21    | 301    |
</span><span class="s">| Lightweight Merino Wool Buff                              | 20    | 50     |
</span><span class="s">| 1 LBD (H&amp;M)                                               | 19    | 174    |
</span><span class="s">| Field Notes Pitch Black Memo Book Dot-Graph               | 18    | 68     |
</span><span class="s">| Innergie PocketCell USB-C 6000mAh power bank              | 17    | 148    |
</span><span class="s">| Important papers                                          | 16    | 228    |
</span><span class="s">| Deuter First Aid Kit Active                               | 15    | 144    |
</span><span class="s">| JBL Reflect Mini Bluetooth Sport Headphones               | 13    | 14     |
</span><span class="s">| Anker SoundCore nano Bluetooth Speaker                    | 12    | 80     |
</span><span class="s">| Oakley Latch Sunglasses                                   | 11    | 30     |
</span><span class="s">| Ray Ban Wayfarer Classic                                  | 10    | 45     |
</span><span class="s">| Zip bag of toiletries                                     | 9     | 236    |
</span><span class="s">| Petzl E+LITE Emergency Headlamp                           | 8     | 27     |
</span><span class="s">| Peak Design Cuff Camera Wrist Strap                       | 6     | 26     |
</span><span class="s">| Travelon Micro Scale                                      | 5     | 125    |
</span><span class="s">| BlitzWolf Bluetooth Tripod/Monopod                        | 4     | 150    |
</span><span class="s">| Humangear GoBites Duo                                     | 3     | 22     |
</span><span class="s">| Vapur Bottle 1L                                           | 1     | 41     |
</span><span class="s">
</span><span class="s">## Which approach is better
</span><span class="s">
</span><span class="s">### Go benchmarking
</span><span class="s">
</span><span class="s">The Go standard library&#39;s `</span><span class="nx">testing</span><span class="s">` package makes it straightforward for us to [benchmark](https://golang.org/pkg/testing/#hdr-Benchmarks) these two approaches. We can find out how long it takes each algorithm to run, and how much memory each uses. Here&#39;s a simple `</span><span class="nx">main_test</span><span class="p">.</span><span class="k">go</span><span class="s">` file:
</span><span class="s">
</span><span class="s">```</span><span class="k">go</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;testing&#34;</span>


 <span class="nx">unc</span> <span class="nf">Benchmark_greedy</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">itemList</span> <span class="o">:=</span> <span class="nf">readItems</span><span class="p">(</span><span class="s">&#34;objects.csv&#34;</span><span class="p">)</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">minaal</span> <span class="o">:=</span> <span class="nx">bag</span><span class="p">{</span><span class="nx">bagWeight</span><span class="p">:</span> <span class="mi">1415</span><span class="p">,</span> <span class="nx">currItemsWeight</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">maxItemsWeight</span><span class="p">:</span> <span class="mi">5585</span><span class="p">}</span>
  <span class="nf">greedy</span><span class="p">(</span><span class="nx">itemList</span><span class="p">,</span> <span class="nx">minaal</span><span class="p">)</span>



 <span class="nx">unc</span> <span class="nf">Benchmark_dynamic</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">itemList</span> <span class="o">:=</span> <span class="nf">readItems</span><span class="p">(</span><span class="s">&#34;objects.csv&#34;</span><span class="p">)</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">minaal</span> <span class="o">:=</span> <span class="nx">bag</span><span class="p">{</span><span class="nx">bagWeight</span><span class="p">:</span> <span class="mi">1415</span><span class="p">,</span> <span class="nx">currItemsWeight</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">maxItemsWeight</span><span class="p">:</span> <span class="mi">5585</span><span class="p">}</span>
  <span class="nf">dynamic</span><span class="p">(</span><span class="nx">itemList</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">minaal</span><span class="p">)</span>


  <span class="s">`
</span><span class="s">
</span><span class="s">We can run `</span><span class="k">go</span> <span class="nx">test</span> <span class="o">-</span><span class="nx">bench</span><span class="p">=.</span> <span class="o">-</span><span class="nx">benchmem</span><span class="s">` to see these results:
</span><span class="s">
</span><span class="s">```</span><span class="nx">sh</span>
<span class="nx">Benchmark_greedy</span><span class="o">-</span><span class="mi">4</span>       <span class="mi">1000000</span>              <span class="mi">1619</span> <span class="nx">ns</span><span class="o">/</span><span class="nx">op</span>            <span class="mi">2128</span> <span class="nx">B</span><span class="o">/</span><span class="nx">op</span>          <span class="mi">9</span> <span class="nx">allocs</span><span class="o">/</span><span class="nx">op</span>
<span class="nx">Benchmark_dynamic</span><span class="o">-</span><span class="mi">4</span>         <span class="mi">1000</span>           <span class="mi">1545322</span> <span class="nx">ns</span><span class="o">/</span><span class="nx">op</span>         <span class="mi">2020332</span> <span class="nx">B</span><span class="o">/</span><span class="nx">op</span>         <span class="mi">49</span> <span class="nx">allocs</span><span class="o">/</span><span class="nx">op</span>
</code></pre></div>
<h4 id="greedy-algorithm-performance" class="anchor-link"><a href="#greedy-algorithm-performance">Greedy algorithm performance</a></h4>
<p>After running the greedy algorithm 1,000,000 times, the speed of the algorithm was reliably measured to be 0.001619 milliseconds (translation: very fast). It required 2128 Bytes or 2-ish kilobytes of memory and 9 distinct memory allocations per iteration.</p>

<h4 id="dynamic-programming-performance" class="anchor-link"><a href="#dynamic-programming-performance">Dynamic programming performance</a></h4>
<p>The dynamic programming algorithm was run 1,000 times. Its speed was measured to be 1.545322 milliseconds or 0.001545322 seconds (translation: still pretty fast). It required 2,020,332 Bytes or 2-ish Megabytes, and 49 distinct memory allocations per iteration.</p>

<h3 id="the-verdict" class="anchor-link"><a href="#the-verdict">The verdict</a></h3>
<p>Part of choosing the right approach to solving any programming problem is taking into account the size of the input data set. In this case, it&rsquo;s a small one. In this scenario, a one-pass greedy algorithm will always be faster and less resource-needy than dynamic programming, simply because it has fewer steps. Our greedy algorithm was almost two orders of magnitude faster and less memory-hungry than our dynamic programming algorithm.</p>
<p>Not having those extra steps, however, means that getting the best possible solution from the greedy algorithm is unlikely.</p>
<p>It&rsquo;s clear that the dynamic programming algorithm gave us better numbers: a lower weight, and higher overall worth.</p>
<table>
<thead>
<tr>
<th></th>
<th>Greedy algorithm</th>
<th>Dynamic programming</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Total weight:</strong></td>
<td>6987g</td>
<td>6955g</td>
</tr>
<tr>
<td><strong>Total worth:</strong></td>
<td>716</td>
<td>757</td>
</tr>
</tbody>
</table>
<p>Where dynamic programming on small data sets lacks in performance, it makes up in optimization. The question then becomes whether that additional optimization is worth the performance cost.</p>
<p>&ldquo;Better,&rdquo; of course, is a subjective judgement. If speed and low resource usage is our success metric, then the greedy algorithm is clearly better. If the total worth of items in the bag is our success metric, then dynamic programming is clearly better. However, our scenario is a practical one, and only one of these algorithm designs returned an answer I&rsquo;d choose. In optimizing for the overall greatest possible total worth of the items in the bag, the dynamic programming algorithm left out my highest-worth, but also heaviest, item: my laptop. The chargers and cables, Roost stand, and keyboard that were included aren&rsquo;t much use without it.</p>

<h3 id="better-algorithm-design" class="anchor-link"><a href="#better-algorithm-design">Better algorithm design</a></h3>
<p>There&rsquo;s a simple way to alter the dynamic programming approach so that the laptop is always included: we can modify the data so that the worth of the laptop is greater than the sum of the worth of all the other items. (Try it out!)</p>
<p>Perhaps in re-designing the dynamic programming algorithm to be more practical, we might choose another success metric that better reflects an item&rsquo;s importance, instead of a subjective worth value. There are many possible metrics we can use to represent the value of an item. Here are a few examples of a good proxy:</p>
<ul>
<li>Amount of time spent using the item</li>
<li>Initial cost of purchasing the item</li>
<li>Cost of replacement if the item were lost today</li>
<li>Dollar value of the product of using the item</li>
</ul>
<p>By the same token, the greedy algorithm&rsquo;s results might be improved with the use of one of these alternate metrics.</p>
<p>On top of choosing an appropriate approach to solving the knapsack problem in general, it is helpful to design our algorithm in a way that translates the practicalities of a scenario into code.</p>
<p>There are many considerations for better algorithm design beyond the scope of this introductory post. One of these is <strong>time complexity</strong>, and I&rsquo;ve <a href="/blog/a-coffee-break-introduction-to-time-complexity-of-algorithms/">written about it here</a>. A future algorithm may very well decide my bag&rsquo;s contents on the next trip, but we&rsquo;re not quite there yet. Stay tuned!</p>


</div>

<div class="page-separator">
    <hr />
</div>


<div class="related">
    
    <div class="markdown highlight">
        <pre class="chroma"><code class="language-sql" data-lang="sql">SELECT TOP 3 * FROM Related;</code></pre>
    </div>
    <ul id="list-items">
        
            <li>
        
        
        
        <a class="li-link" href="https://victoria.dev/blog/a-coffee-break-introduction-to-time-complexity-of-algorithms/">A coffee-break introduction to time complexity of algorithms</a>
        <p class="li-brief">
            A groundwork understanding of algorithm time complexity in about fifteen minutes.
        </p>
        <p class="metadata">
            
            <a class="li-tag" href="/tags/algorithms/">algorithms</a>
            
            ‚òïÔ∏è‚òïÔ∏è‚òïÔ∏è&nbsp;
            16 min read
        </p>
        
        
        
    </li>

        
            <li>
        
        
        
        <a class="li-link" href="https://victoria.dev/blog/sqlite-in-production-with-wal/">SQLite in production with WAL üî•</a>
        <p class="li-brief">
            An underappreciated candidate for light and fast database transactions.
        </p>
        <p class="metadata">
            
            <a class="li-tag" href="/tags/data/">data</a>
            
            ‚òïÔ∏è&nbsp;
            4 min read
        </p>
        
        
        
    </li>

        
            <li>
        
        
        
        <a class="li-link" href="https://victoria.dev/blog/multithreaded-python-slithering-through-an-i/o-bottleneck/">Multithreaded Python: slithering through an I/O bottleneck</a>
        <p class="li-brief">
            How taking advantage of parallelism in Python can make your software orders of magnitude faster.
        </p>
        <p class="metadata">
            
            <a class="li-tag" href="/tags/python/">python</a>
            
            ‚òïÔ∏è&nbsp;
            5 min read
        </p>
        
        
        
    </li>

        
    </ul>
    

    <div class="page-separator">
        <p class="back-link"><a href="/blog">
                &lt;&lt; Back to blog</a> </p> </div> </div> 
        </div>

        <div class="container">
            
            <footer>
    
    
    
    
    
    <div class="markdown">
        
        <figure class="profile">
    <img src="/img/victoria_headshot.jpg"
         alt="Victoria&#39;s headshot"/> 
</figure>

<p>Victoria Drake is a senior software developer in Washington, DC. She currently serves as a core maintainer and co-author for the Open Web Application Security Project (OWASP) Web Security Testing Guide. She earned the annual Top Contributor award two years in a row from the freeCodeCamp non-profit, and is a recognized Distinguished Author on the DEV.to developer platform. She writes about software development, cybersecurity, and information security awareness.</p>
<p><a href="/about">about</a> - <a href="mailto:hello@victoria.dev">email</a> - <a href="https://github.com/victoriadrake">github</a> - <a href="https://twitter.com/victoriadotdev">twitter</a> - <a href="https://www.linkedin.com/in/victoriadotdev/">linkedin</a></p>

    </div>
    
    
</footer>

            
        </div>
    </section>

    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-98623582-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


    

    
    
    

</body>

</html>
